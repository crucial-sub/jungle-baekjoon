import sys
input = sys.stdin.readline

### 로어바운드 공부할것

def main():
    N = int(input())
    arr_a = list(map(int, input().split()))
    LIS = []
    """
    가장 긴 증가하는 부분 수열(LIS)과 이분 탐색(Lower Bound)
    LIS 배열은 실제 LIS 수열 자체를 저장하는 것이 아니다 ! <- 이것이 핵심 포인트!
    LIS[k] = 길이가 k+1인 증가 부분 수열을 만들 수 있는 마지막 숫자 중 가장 작은 값
    
    예를 들어, LIS[2] = 30 이라면, 
    => "길이가 3인 증가 부분 수열 중 마지막이 30으로 끝나는 경우가 있고, 
    => 30은 가능한 값 중 가장 작은 값이다"라는 뜻

    왜 마지막 숫자를 "가장 작게" 유지해야 할까?
    => 끝나는 숫자가 작을수록, 그 뒤에 더 많은 숫자들이 이어질 수 있는 가능성이 열리기 때문

    예를 들어 [10, 20, 30] 보다는 [10, 20, 25]가 더 '좋은' 길이 3짜리 수열이다. 
    왜냐하면 25 뒤에는 26, 27...등이 올 수 있지만
    30 뒤에는 31부터만 올 수 있기 때문이다.

    이 아이디어를 가지고, 원래 수열 A를 처음부터 순회하면서 LIS 배열을 채워나간다.

    수열 A의 i번째 원소 A[i]에 대해 두 가지 경우만 존재

    1. A[i]가 LIS 배열의 마지막 원소보다 클 경우:
    이것은 가장 긴 증가 부분 수열의 길이를 1 늘릴 수 있다는 의미
    why? 새로운 숫자가 기존의 가장 긴 수열 뒤에 붙을 수 있기 때문
    => A[i]를 LIS 배열의 맨 뒤에 추가

    2. A[i]가 LIS 배열의 마지막 원소보다 크지 않을 경우:
    이 숫자는 기존의 가장 긴 수열을 연장시키지는 못함 
    BUT! 기존 LIS 배열의 중간에 있는 어떤 값을 더 작은 값으로 '개선'할 수 있는 기회는 가질 수 있음
    => LIS 배열에서 A[i]보다 "크거나 같은 숫자 중 가장 먼저 나오는 숫자를 찾아" A[i]로 교체

    바로 이 "크거나 같은 숫자 중 가장 먼저 나오는 위치"를 찾는 작업이 이분 탐색이고,
    lower_bound가 정확히 이 역할을 수행한다.
    """

    LIS.append(arr_a[0]) # 첫 번째 원소로 LIS 리스트 초기화

    for i in range(1,N):
        a = arr_a[i]
        if a > LIS[-1]: # 수열 A의 원소 a에 대한 첫 번째 경우
            LIS.append(a)
        else:             # 수열 A의 원소 a에 대한 두 번째 경우
            # LIS 배열안에 a가 들어갈 위치 right를 이분 탐색으로 직접 찾는다 (lower_bound 구현)
            start = 0
            end = len(LIS) - 1

            # LIS에서 a보다 크거나 같은 첫 번째 값의 위치를 찾는다.
            while start < end:
                mid = (start+end) // 2
                if a > LIS[mid]: # a > LIS[mid]이면 a가 들어갈 자리는 mid보다 무조건 오른쪽에 있다.
                    start = mid + 1 # 따라서 start = mid + 1 (다음 루프를 돌 때 탐색 범위 시작점을 mid 바로 다음 인덱스로 하겠다는 뜻)
                else:  # LIS[mid] >= a 이면, mid가 a가 들어갈 위치일 수도 있고, 더 왼쪽일 수도 있다.
                    end = mid # 따라서 end = mid로 설정하여 mid를 포함한 왼쪽을 계속 탐색!

            LIS[end] = a # 찾은 위치의 값을 a로 교체

    print(len(LIS))

if __name__ == "__main__":
    main()